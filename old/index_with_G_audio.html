<html>
<style>
	body {
		margin: 0;
	}

	.container {
		position: absolute;
		width: 100vw;
		height: 100vh;
		/*border: 5px solid red;*/
		display: flex;
		justify-content: center;
		align-items: center;
	}

	button {
		z-index: 265;
		display: grid;
		justify-content: center;
		/*padding: 0.35em 1.2em;*/
		border: 0.05em transparent;
		margin: auto;
		/*margin: 0 0.5em 0.5em 0;*/
		/*border-radius: 0.12em;*/
		/*box-sizing: border-box;*/
		/*text-decoration: none;*/
		font-family: 'Roboto', sans-serif;
		font-weight: 200;
		font-size: x-large;
		color: #000000;
		text-align: center;
		background-color: transparent;
		/*transition: all 0.2s;*/
		padding: 10%;
		border-radius: 50%;
	}
</style>

<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.min.js"></script>
</head>

<body>
	<!--
	<div id="overlay">
		<button id="startButton">Play</button>
	</div>
	-->

	<script id="fragShader" type="shader-code">
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D videoTexture;

		uniform float time;
		uniform int iFrame;
		void main() {
			vec2 st = gl_FragCoord.xy / iResolution;
			vec2 uv = st;
			uv *= 0.998;

			vec4 sum = texture2D(bufferTexture, uv);
			vec4 src = texture2D(videoTexture, uv);
			sum.rgb = mix(sum.rbg, src.rgb, 0.1);
			gl_FragColor = sum;
		 	
		 }
	</script>

	<script id="fragmentShader_buffer_A" type="x-shader/x-fragment">
		//#extension GL_OES_standard_derivatives : enable

		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		//varying vec2 vUv;
		uniform sampler2D iChannel0;
		uniform sampler2D iChannel1;

		uniform float iTime;
		uniform int iFrame;
		uniform vec3 sColor;
		uniform vec4 iMouse;
		uniform vec2 id;

		/*
		void main()
		{
			vec2 uv = gl_FragCoord.xy / iResolution.xy;
			vec4 tex = texture2D(iChannel0, uv);
			gl_FragColor = tex;
			gl_FragColor = vec4(sColor,1.);
			//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
		*/
		
		vec4 fragColor;
		
        // Original by:
		//2013, George Toledo. Based on tons of glsl sandbox code with additions to make it a filter.
		//change lightMode and mess with N to change lighting.
		//displaceMode lets cell noise be affected by texture brightness.
		//distance formula sets up a mix between linear and manhattan.
		//webGL and desktop both seem to optimize all conditional stuff fine on this computer.

		// Re-programmed with additional modes by Louise Less√©l
		/// www.louiselessel.com
		// original here: https://www.shadertoy.com/view/lsf3DS

		//webGL v0.1 Sep. 3, 2013 (desktop, 4/2/13)
		//webGL v0.2 Sep. 3, 2013 (desktop, 4/2/13). - set uv in main
		//webGL v0.3 Sep. 3, 2013 (desktop, 4/5/13). - adjust for vid
 

		int lightMode_0_4 = 4;
		uniform float density_1_100;
		uniform float zoom_0_1;
		uniform float UV_OffsetX;
		uniform float UV_OffsetY;
		uniform float displaceAmt_0_1;
		uniform float distFormula_0_1;
		float edges = 0.05;
		

		#define density density_1_100 //40.00
		#define displaceMode 1
		#define displaceAmt 0.0
		#define lightMode lightMode_0_4 // 4
		//distFormula 0 is linear, 1 is manhattan, you can mix between
		#define distFormula 0.0
		#define uvOffset vec2(0.02,0.02)
		#define zoom 0.04
		// N vec4(0.) for no holes on facet
		#define N vec4(0.0,0.0,0.0,0.)

		float jitter;

		float jit(float jitter, float lum){
			if (displaceMode==0)
				return jitter=lum*displaceAmt;	//more jitter in brighter areas
			else if (displaceMode==1)
				return jitter=1.-lum*displaceAmt;	//more jitter in darker areas
			else
				return jitter=displaceAmt;	//disregard texture in jitter creation
		}

		//uses cellular noise for jitter basis

		// Cellular noise ("Worley noise") in 2D in GLSL.
		// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
		// This code is released under the conditions of the MIT license.
		// See LICENSE file for details, located in ZIP file here:
		// http://webstaff.itn.liu.se/~stegu/GLSL-cellular/

		// Permutation polynomial: (34x^2 + x) mod 289
		vec3 permute(vec3 x) {
			return mod((34.0 * x + 1.0) * x, 289.0);
		}


		// Cellular noise, returning F1 and F2 in a vec2.
		// Standard 3x3 search window for good F1 and F2 values
		vec2 cellular(vec2 P, float jitter, float lum) {
			#define K 0.142857142857 // 1/7
			#define Ko 0.428571428571 // 3/7

			vec2 Pi = mod(floor(P), 289.0);
			vec2 Pf = fract(P);
			vec3 oi = vec3(-1.0, 0.0, 1.0);
			vec3 of = vec3(-0.5, 0.5, 1.5);
			vec3 px = permute(Pi.x + oi);
			vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
			vec3 ox = fract(p*K) - Ko;
			vec3 oy = mod(floor(p*K),7.0)*K - Ko;
			vec3 dx = Pf.x + 0.5 + jit(jitter, lum)*ox;
			vec3 dy = Pf.y - of + jit(jitter, lum)*oy;
			
			vec3 d1 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d11, d12 and d13, squared, mixed with not squared
			p = permute(px.y + Pi.y + oi); // p21, p22, p23
			ox = fract(p*K) - Ko;
			oy = mod(floor(p*K),7.0)*K - Ko;
			dx = Pf.x - 0.5 + jit(jitter, lum)*ox;
			dy = Pf.y - of + jit(jitter, lum)*oy;
			vec3 d2 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d21, d22 and d23, squared
			p = permute(px.z + Pi.y + oi); // p31, p32, p33
			ox = fract(p*K) - Ko;
			oy = mod(floor(p*K),7.0)*K - Ko;
			dx = Pf.x - 1.5 + jit(jitter, lum)*ox;
			dy = Pf.y - of + jit(jitter, lum)*oy;
			vec3 d3 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d31, d32 and d33, squared

			// Sort out the two smallest distances (F1, F2)
			vec3 d1a = min(d1, d2);
			d2 = max(d1, d2); // Swap to keep candidates for F2
			d2 = min(d2, d3); // neither F1 nor F2 are now in d3
			d1 = min(d1a, d2); // F1 is now in d1
			d2 = max(d1a, d2); // Swap to keep candidates for F2
			d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
			d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
			d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
			d1.y = min(d1.y, d1.z); // nor in  d1.z
			d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
			return mix(sqrt(d1.xy),d1.xy,distFormula);
		}

		vec2 cellularID(vec2 P, float jitter, float lum) {
			vec2 Pi = mod(floor(P), 289.0);
			vec2 Pf = fract(P);
			vec3 oi = vec3(-1.0, 0.0, 1.0);
			vec3 of = vec3(-0.5, 0.5, 1.5);
			vec3 px = permute(Pi.x + oi);
			vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
			vec3 ox = fract(p*K) - Ko;
			vec3 oy = mod(floor(p*K),7.0)*K - Ko;
			vec3 dx = Pf.x + 0.5 + jit(jitter, lum)*ox;
			vec3 dy = Pf.y - of + jit(jitter, lum)*oy;
			vec3 d1 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d11, d12 and d13, squared, mixed with not squared
			p = permute(px.y + Pi.y + oi); // p21, p22, p23
			ox = fract(p*K) - Ko;
			oy = mod(floor(p*K),7.0)*K - Ko;
			dx = Pf.x - 0.5 + jit(jitter, lum)*ox;
			dy = Pf.y - of + jit(jitter, lum)*oy;
			vec3 d2 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d21, d22 and d23, squared
			p = permute(px.z + Pi.y + oi); // p31, p32, p33
			ox = fract(p*K) - Ko;
			oy = mod(floor(p*K),7.0)*K - Ko;
			dx = Pf.x - 1.5 + jit(jitter, lum)*ox;
			dy = Pf.y - of + jit(jitter, lum)*oy;
			vec3 d3 = mix(dx * dx + dy * dy,  abs(dx) + abs(dy), distFormula); // d31, d32 and d33, squared
		
			float f1 = d1.x;
			vec2 ci = vec2(Pi.x - 1.0, Pi.y - 1.0);
			if (d1.y < f1) { f1 = d1.y; ci = vec2(Pi.x - 1.0, Pi.y); }
			if (d1.z < f1) { f1 = d1.z; ci = vec2(Pi.x - 1.0, Pi.y + 1.0); }
			if (d2.x < f1) { f1 = d2.x; ci = vec2(Pi.x      , Pi.y - 1.0); }
			if (d2.y < f1) { f1 = d2.y; ci = vec2(Pi.x      , Pi.y); }
			if (d2.z < f1) { f1 = d2.z; ci = vec2(Pi.x      , Pi.y + 1.0); }
			if (d3.x < f1) { f1 = d3.x; ci = vec2(Pi.x + 1.0, Pi.y - 1.0); }
			if (d3.y < f1) { f1 = d3.y; ci = vec2(Pi.x + 1.0, Pi.y); }
			if (d3.z < f1) { f1 = d3.z; ci = vec2(Pi.x + 1.0, Pi.y + 1.0); }
			return mod(ci, 289.0);
		}

		vec3 hsv(const in float h, const in float s, const in float v) {
			return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;
		}

		vec2 mouseMap() {
			vec2 m = iMouse.xy / iResolution.xy;
			return m;
		}

		void main() {

            vec2 uv = (gl_FragCoord.xy / iResolution.xy)*(1.-zoom)+uvOffset;
			//vec2 uv=(2.-vec2(-gl_FragCoord.xy.x,gl_FragCoord.xy.y)/iResolution.xy)*(1.-zoom)+uvOffset;
			
			vec4 tx=texture2D(iChannel0,uv);
			float lum=length(tx.rgb);

			// make cells
			vec2 position = uv * density;
			//move positions
			//position = 0.5 + 0.5 * sin(iTime*0.001 + 6.2831*position) ;

			vec2 Fid = cellularID(position, jitter, lum);

			// sample images from cells
			vec4 tx0=texture2D(iChannel0,Fid/density); 			// img 1
			vec4 tx1=texture2D(iChannel1,Fid/density); 			// img 2

			vec2 mouse = mouseMap();							// blend between
			vec4 tx2=mix(tx0, tx1, mouse.x); 

			// add mouse as position messer upper
			//point[4] = u_mouse/u_resolution;

			vec2 F = cellular(position, jitter, lum);
			vec2 Fx = cellular(position-vec2(0.0,0.0), jitter, lum);
			vec2 Fy = cellular(position-vec2(0.0,0.0), jitter, lum);

			//Fx = cellular(position-vec2(iMouse.y,0.0), jitter, lum);
			//Fy = cellular(position-vec2(0.0,iMouse.y), jitter, lum);
			
			float nBasic = 0.1+(F.y-F.x);
			nBasic = (F.y-F.x);

			float facets = 0.1+abs(F.y*(N.x+N.y)-F.x);
			float facetsX = 0.1+abs(Fx.y*(N.x+N.z)-Fx.x);
			float facetsY = 0.1+abs(Fy.y*(N.x+N.w)-Fy.x);
			
			vec3 normalFacet = vec3(facets - facetsX, facets - facetsY, 0.1);
			vec4 fc = vec4(-dot(normalize(normalFacet),normalize(vec3((uv)-.5,-1.0))));

			if(lightMode==0){
				vec3 color = vec3(tx2.rgb);
				fragColor = vec4( color, 1.0);
			}
			else if(lightMode==1){
				vec3 color = vec3(tx2.rgb) * nBasic;	
				fragColor = vec4( color, 1.0);
			}
			else if(lightMode==2){
				vec3 color = vec3(tx2.rgb) * fc.rgb;	
				fragColor = vec4( color, 1.0);
			}	
			else if(lightMode==3){
				vec3 color = normalize(normalFacet)+.5;	
				fragColor = vec4( color, 1.0);
			}
			else if(lightMode==4){
				vec3 mask = vec3(tx2.rgb)* nBasic;
				if (mask.r < edges) { mask.rgb = vec3(0.);}
				else { mask.rgb = vec3(1.); }
				vec3 color = vec3(tx2.rgb * mask);
				//vec2 id = vec2(1.,1.);
				if (Fid.x == id.x && Fid.y == id.y) {
					color = vec3(sColor);
					color *= mask;
				}
				fragColor = vec4(color, 1.0);
			}
			gl_FragColor = fragColor;	
		}
	  </script>


	<script id="fragmentShader_buffer_B" type="x-shader/x-fragment">
		//#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;

		vec4 fragColor;
		uniform sampler2D iChannel0; // takes buffer of self
		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;

		/*
		 void main()
		{
			gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
		}
		*/

		const float Key_R = 82.5 / 256.;
		const float Key_X = 88.5 / 256.;
		const float Key_Space = 32.5 / 256.;

		#define t2D(o) texture(iChannel0, uv-o/res)
		#define isKeyHeld(key) texture(iChannel3, vec2(key, .2)).r > 0.
		#define dataAt(x) texture(iChannel0, vec2(x+.5, .5)/res)

		// hash without sine
		// https://www.shadertoy.com/view/4djSRW

		#define MOD3 vec3(443.8975,397.2973, 491.1871)

		float hash12(vec2 p) {
			vec3 p3  = fract(vec3(p.xyx) * MOD3);
			p3 += dot(p3, p3.yzx + 19.19);
			return fract((p3.x + p3.y) * p3.z);
		}

		//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
		voide main() {
			vec2 res = iResolution.xy;
			vec2 fc = gl_FragCoord;
			vec2 uv = fc / res;
			vec3 o = vec3(1., -1., 0.);
			
			vec2 dirs[8];
			dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;
			dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;
			
			vec2 pos = t2D(o.zz).rg;
			vec2 sPos = dataAt(2.).ba;
			vec2 mOld = dataAt(0.).ba;
			float isMHeld = dataAt(1.).b;
			
			for(int i=0; i<8; i++) {
				// neighbor's stored position
				vec2 iPos = t2D(dirs[i]).rg;
				
				// if circle produced by neighbor is less than the current one, take its position
				if(length(fc-iPos) < length(fc-pos))
					pos = iPos;
			}
			
			if(iMouse.z>0.) {
				// cell position under mouse
				vec2 posUnderMouse = texture(iChannel0, iMouse.xy/res).rg;
				
				// remove cell
				if(isKeyHeld(Key_X)) {
					if(pos==posUnderMouse)
						pos = vec2(-10000.);
				}
				else
					// move cell
					if(isKeyHeld(Key_Space)){
						// mouse button is held
						if(isMHeld==1.) {
							// update cell position
							if(sPos==pos)
								pos += iMouse.xy - mOld;
							
							// update temporary position
							sPos += iMouse.xy - mOld;
							
							// stamp new position into buffer (for faster movement)
							if(length(fc-sPos)<length(fc-pos))
								pos = sPos;
						}
						// mouse button is clicked but not held
						else
							// set temporary position when mouse is first clicked
							sPos = posUnderMouse;
					}
					else
						// add cell
						if(length(fc-iMouse.xy)<length(fc-pos))
						pos = iMouse.xy;
					
				isMHeld = 1.;
			}
			else
				isMHeld = 0.;
			
			mOld = iMouse.xy;
				
			// initialize values first frame
			if(iFrame==0) {
				if(pow(length(fc/res.y-vec2(.5*res.x/res.y, 0.)), 32.)>hash12(uv))
					pos = fc;
				else
					pos = vec2(-10000.);
				isMHeld = 0.;
			}
			
			// clear stored positions when R is pressed
			if(isKeyHeld(Key_R))
				pos = vec2(-10000.);
			
			// save cell position(s)
			fragColor.rg = pos;
			
			// save old mouse position
			if(floor(fc)==o.zz)
				fragColor.ba = mOld;
			else
				// save button held state
				if(floor(fc)==o.xz)
					fragColor.b = isMHeld;
				else
					// save temporary, moving cell position
					if(floor(fc)==vec2(2., 0.))
						fragColor.ba = sPos;
			gl_FragColor = fragColor;
		}    
	
	</script>

	<script id="fragmentShader_buffer_C" type="x-shader/x-fragment">
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		//varying vec2 vUv;

		uniform float iTime;
		uniform int iFrame;

		 void main()
		{
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		}
	  </script>

	<script id="fragmentShader_image" type="x-shader/x-fragment">
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		//varying vec2 vUv;

		vec4 fragColor;
		uniform sampler2D iChannel0; // takes buffer of self
		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;

		 // straight sampling from img or buffer
		 void main()
		{
			vec4 tex = texture2D(iChannel0, gl_FragCoord.xy / iResolution.xy);
			gl_FragColor = tex;

			//vec4 img = texture2D(imgTexture, gl_FragCoord.xy / iResolution.xy);
			//gl_FragColor = mix(tex.rgb, img.rgb, 0.5);
			//vec2 uv = gl_FragCoord.xy / iResolution.xy;
			//if(uv.x<0.25) gl_FragColor = vec4(1,1,1,1);
			
			//gl_FragColor = vec4(0.,0.,1.,1.);
		}

/*

		//Based on https://www.shadertoy.com/view/4sK3WK by stb

		#define t2D(o) texture2D(iChannel0, uv-o/res)
		#define plane(p, n) 1. - abs(dot(p, n))*res.y

		//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {

		void main() {
			vec2 res = iResolution.xy;
			vec2 uv = fragCoord / res;
			vec2 p = fragCoord / res.y;
			vec3 o = vec3(1., -1., 0.);
			
			vec2 dirs[4];
			dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;
			
			// current position
			vec2 pos = t2D(o.zz).rg;
			
			float c, w = 0.;
			
			// cell gradient
			c = pos.y*0.003;
			//c = (p-pos/res.y).r;// length(p-pos/res.y);
			
			// cell walls
			for(int i=0; i<6; i++) {
				vec2 iPos = t2D(dirs[i]).rg;
				if(pos!=iPos)
					w = max(w, plane(p-mix(pos, iPos, .5)/res.y, normalize(pos-iPos)));
					//w = 1.-w;
			}
			vec4 col = vec4(vec3(c) *vec3(.7, .6, .5)+w , 1.);
			float threshold = 0.99;
			if (col.r > threshold && col.g > threshold && col.b > threshold) {
				//col.rgb= vec3(0.);
				col.a = 0.;
				}
			fragColor = col;
*/

	  </script>


	<script>
		var scene;
		var camera;

		var texture0;
		var texture1;
		var buffercamera;

		var renderer;
		var bufferScene;
		var bufferScene_A;

		var textureA;
		var textureB;
		var textureBB;
		var textureC;
		var textureD;
		var textureImage;

		var bufferMaterial;
		var bufferMaterial_A;
		var bufferObject_A;

		var plane;
		var bufferObject;

		var finalMaterial;
		var quad;
		var video;
		var videoTexture;

		var iTime;
		var iFrame;
		const iMouse = new THREE.Vector4();
		var iMousePressed = false;
		var startTime = Date.now();
		var timeScalar = 1.;
		
		// color palette
		var c1 = new THREE.Vector3(244 / 255, 46 / 255, 86 / 255);
		var c2 = new THREE.Vector3(245 / 255, 210 / 255, 87 / 255);
		var c3 = new THREE.Vector3(199 / 255, 199 / 255, 199 / 255);
		var c4 = new THREE.Vector3(190 / 255, 199 / 255, 92 / 255);
		var c5 = new THREE.Vector3(54 / 255, 93 / 255, 187 / 255);

		// shader color
		var sColor = new THREE.Vector3(0., 0., 0);
		var id = new THREE.Vector2(0, 0);
		var last_highesti;

		//const width = 1920;
		//const height = 1080;
		//const rtWidth = 1920;
		//const rtHeight = 1080;
		
		const width = window.innerWidth;
		const height = window.innerHeight;
		const rtWidth = window.innerWidth;
		const rtHeight = window.innerHeight;

		// SOUND
		let analyser;
		let data;
		const fftSize = 32;


		//const startButton = document.getElementById('startButton'); // there must be a button for sound
		//startButton.addEventListener('click', init);

		function init() {
			//Hide button
			//const overlay = document.getElementById('overlay');
			//overlay.remove();

			//gloriaSound();
			initVars();
			sceneSetup();
			bufferTextureSetup(); //Setup the frame buffer scenes we're going to be rendering to instead of the screen
			render();
		}

		function initVars() {
			console.log("init");
			window.addEventListener('mousemove', onMouseMove, false);
			var elapsedMilliseconds = Date.now() - startTime;
        	//var elapsedSeconds = elapsedMilliseconds / 1000.;
        	iTime = elapsedMilliseconds * timeScalar;
			iFrame = 0;
		}

		function gloriaSound() {
			const listener = new THREE.AudioListener();
			const audio = new THREE.Audio(listener);
			const file = './Audio/Mass_Gloria_1-31-21SOUND_HARP ONLY.mp3'; // './sounds/376737_Skullbeatz___Bad_Cat_Maste.mp3';
			console.log(file);

			//if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent)) {
			const loader = new THREE.AudioLoader();
			loader.load(file, function (buffer) {
				audio.setBuffer(buffer);
				audio.play();
			});
			//}
			//else {
			const mediaElement = new Audio(file);
			mediaElement.loop = true;
			mediaElement.play();
			audio.setMediaElementSource(mediaElement);
			//}

			analyser = new THREE.AudioAnalyser(audio, fftSize);
			console.log(analyser);
		}

		function updateAudio() {

			data = analyser.getFrequencyData();

			// find highest energy frequency
			var highestf = 0;
			var highesti = 0;

			for (i = 0; i < data.length; i++) {
				if (highestf < data[i]) {
					highestf = data[i];
					highesti = i;
				}
			}

			if (highesti == 0) sColor = c1;
			if (highesti == 1) sColor = c2;
			if (highesti == 2) sColor = c3;
			if (highesti == 3) sColor = c4;
			else if (highesti > 3) sColor = c5;

			if (last_highesti != highesti) {
				var min = 1;
				var max = 40;
				id.x = Math.floor((Math.random() * max) + min);
				id.y = Math.floor((Math.random() * max) + min);
			}
			//console.log(id);
			//console.log (sColor);

			// get the average frequency of the sound
			//console.log(analyser.getAverageFrequency ());

			//console.log(audio.isPlaying);
			//console.log(data);

			// store so we can check if it changed
			last_highesti = highesti;
		}

		function onMouseMove(event) {
			// calculate mouse position in normalized device coordinates
			// (-0.5 to +0.5) for both components
			//iMouse.x = ( event.clientX / window.innerWidth ) - 0.5;
			//iMouse.y = (( event.clientY / window.innerHeight ) - 0.5) * -1.;

			// calculate mouse position in normalized device coordinates
			// 0 - 1
			//iMouse.x = ( event.clientX / window.innerWidth );
			//iMouse.y = (( event.clientY / window.innerHeight ) - 1) * -1.;

			// no mapping - pixel coordinates width and height, but height is flipped
			iMouse.x = event.clientX;
			iMouse.y = height - (event.clientY); //1.0 - uv.y;
			//console.log(iMouse.x);
			//console.log(iMouse.y);
			//console.log(event.buttons);
			if (event.buttons > 0) {	// button is pressed
				//console.log("pressed");
				if (!iMousePressed) { 	// if it wasn't pressed last frame
					iMouse.z = iMouse.x;
					iMouse.w = iMouse.y;
					iMousePressed = true;
					console.log('iMouse.z');
					console.log(iMouse.z);
					console.log(iMouse.w);
				}
			}
			if (event.buttons == 0) {
				iMousePressed = false;
				iMouse.z = 0.;
				iMouse.w = 0.;
				//console.log("not pressed");
			}
		}

		const PARAMS = {
			//wrapS: THREE.ClampToEdgeWrapping, //THREE.RepeatWrapping,
			//wrapT: THREE.ClampToEdgeWrapping, //THREE.RepeatWrapping,
			minFilter: THREE.LinearFilter,
			magFilter: THREE.NearestFilter //THREE.LinearFilter,//
			//format: THREE.RGBAFormat,
			//type: THREE.FloatType,
			//stencilBuffer: false
		};

		function sceneSetup() {
			scene = new THREE.Scene();
			camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
			camera.position.z = 1;

			// create final texture
			textureImage = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );
			//finalMaterial =  new THREE.MeshBasicMaterial({map: textureImage.texture});
			finalMaterial = new THREE.ShaderMaterial({
				uniforms: {
					bufferTexture: { type: "t", value: textureA.texture },
					iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
					imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					iChannel0: { type: "t", value: textureB.texture },
					//iChannel1: { type: "t", value: textureBB.texture },
					//iChannel2: { type: "t", value: textureCC.texture },
					iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
					iFrame: { type: "i", value: 0 },
					iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
				},
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader_image').textContent
			});	

			plane = new THREE.PlaneBufferGeometry(width, height);
			quad = new THREE.Mesh(plane, finalMaterial);
			scene.add(quad);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(width, height);
			document.body.appendChild(renderer.domElement);
		}

		/*
		function videoTextureSetup() {
			video = document.getElementById( 'video' );
			videoTexture = new THREE.VideoTexture( video );

			videoTexture.minFilter = THREE.LinearFilter;
			videoTexture.magFilter = THREE.LinearFilter;
			videoTexture.format = THREE.RGBFormat;
		}
		*/


		function bufferTextureSetup() {
			texture0 = new THREE.TextureLoader().load('textures/mammoth.png');
			texture1 = new THREE.TextureLoader().load('textures/butterfly.png');

			//Create buffer textures
			textureA = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );
			textureB = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );
			textureC = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );
			textureD = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );
			textureBB = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS );

			buffercamera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
			buffercamera.position.z = 2;
			//Create buffer scene
			bufferSceneA = new THREE.Scene();
			bufferSceneB = new THREE.Scene();
			bufferSceneC = new THREE.Scene();

			//Pass texture to shader
			bufferMaterial_A = new THREE.ShaderMaterial({
				uniforms: {
					bufferTexture: { type: "t", value: textureA.texture },
					iResolution: { type: 'v2', value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					//Keeps the resolution
					//videoTexture: {type: "t", value: videoTexture },
					imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					//iChannel0: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					iChannel0: { type: "t", value: texture0 },
					iChannel1: { type: "t", value: texture1 },
					iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
					iFrame: { type: "i", value: 0 },
					iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) },
					density_1_100: {type: "f", value: iMouse.y },
					sColor: { type: "v3", value: sColor },
					id: { type: "v2", value: id }
				},
				//fragmentShader: document.getElementById( 'fragShader' ).innerHTML
				fragmentShader: document.getElementById('fragmentShader_buffer_A').innerHTML
			});
			//Pass texture to shader
			bufferMaterial_B = new THREE.ShaderMaterial({
				uniforms: {
					bufferTexture: { type: "t", value: textureA.texture },
					iResolution: { type: 'v2', value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					//Keeps the resolution
					//videoTexture: {type: "t", value: videoTexture },
					imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					iChannel0: { type: "t", value: textureBB.texture },
					iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
					iFrame: { type: "i", value: 0 },
					iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) },
				},
				//fragmentShader: document.getElementById( 'fragShader' ).innerHTML
				fragmentShader: document.getElementById('fragmentShader_buffer_B').innerHTML
			});
			//Pass texture to shader
			bufferMaterial_C = new THREE.ShaderMaterial({
				uniforms: {
					bufferTexture: { type: "t", value: textureA.texture },
					iResolution: { type: 'v2', value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					//Keeps the resolution
					//videoTexture: {type: "t", value: videoTexture },
					imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					iChannel0: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
					iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
					iFrame: { type: "i", value: 0 }
				},
				//fragmentShader: document.getElementById( 'fragShader' ).innerHTML
				fragmentShader: document.getElementById('fragmentShader_buffer_C').innerHTML
			});

			bufferObject = new THREE.Mesh(plane, bufferMaterial_A);
			bufferSceneA.add(bufferObject);
			bufferObject = new THREE.Mesh(plane, bufferMaterial_B);
			bufferSceneB.add(bufferObject);
			bufferObject = new THREE.Mesh(plane, bufferMaterial_C);
			bufferSceneC.add(bufferObject);
		}


		function updateUniforms(buffer) {
			buffer.uniforms.iTime.value = iTime;
			buffer.uniforms.iFrame.value = iFrame;
			buffer.uniforms.iMouse.value = iMouse;
			buffer.uniforms.density_1_100.value = 45.;//iMouse.y;

		}
		function render() {
			requestAnimationFrame(render);
			//updateAudio();

			// Make shader on quad BufferA - change input buffers - Draw bufferScene to textureA
			renderer.setRenderTarget(textureA);
			renderer.render(bufferSceneA, buffercamera);
			//finalMaterial.uniforms.bufferTexture.value = textureA.texture;	// test that it gets passed into image
			renderer.setRenderTarget(null);
			
			// Make shader on quad BufferB - change input buffers - Draw bufferScene to textureB
			renderer.setRenderTarget(textureB);
			renderer.render(bufferSceneB,buffercamera,textureB,true);
			//finalMaterial.uniforms.bufferTexture.value = textureB.texture;	// test that it gets passed into image
			renderer.setRenderTarget(null);
			textureBB = textureB;
			bufferMaterial_B.uniforms.iChannel0.value = textureBB;

				/*
			// Make shader on quad BufferC - change input buffers - Draw bufferScene to textureC
			renderer.setRenderTarget(textureC);
			renderer.render(bufferSceneC,buffercamera,textureC,true);
			//finalMaterial.uniforms.bufferTexture.value = textureC.texture;	// test that it gets passed into image
			renderer.setRenderTarget(null);
				*/

			//Update uniforms
			updateUniforms(bufferMaterial_A);
			bufferMaterial_A.uniforms.sColor.value = sColor;
			bufferMaterial_A.uniforms.id.value = id;

			var elapsedMilliseconds = Date.now() - startTime;
        	var elapsedSeconds = elapsedMilliseconds / 1000.;
        	iTime = elapsedMilliseconds * timeScalar; 			//60. * elapsedSeconds;
			iFrame += 1;

			finalMaterial.uniforms.bufferTexture.value = textureA.texture;	// test that it gets passed into image
			//Finally, draw to the screen
			//quad.material.map = textureA.texture;
			//quad.material.map = textureImage.texture;
			renderer.render(scene, camera);

		}
	</script>
</body>

</html>