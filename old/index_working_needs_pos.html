<html>

<style>
    body {
        width: 100%;
        height: 100%;
        margin: 0px;
        padding: 0px;
        overflow-x: hidden;
    }
</style>

<head>
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/85/three.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.min.js"></script>
</head>

<body>
    <script id="vertexShader" type="x-shader/x-vertex">

		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;
		uniform sampler2D iChannel0;
		uniform sampler2D iChannel1;
		uniform sampler2D iChannel2;
		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;
  
		void main()	{
		  //gl_Position = vec4(position, 1.0 );
		  vUv = uv;
		  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}
	  </script>

    <script id="fragShader" type="shader-code">
		#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D videoTexture;
		varying vec2 vUv;

		uniform float time;
		uniform int iFrame;
		uniform vec4 iMouse;

		void main() {
			vec2 st = gl_FragCoord.xy / iResolution;
			vec2 uv = st;
			uv *= 0.998;

			vec4 sum = texture2D(bufferTexture, uv);
			vec4 src = texture2D(videoTexture, uv);
			sum.rgb = mix(sum.rbg, src.rgb, 0.1);
			gl_FragColor = sum;
		 	
		 }
	</script>

    <script id="fragmentShader_buffer_A" type="x-shader/x-fragment">
		//#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;

		uniform sampler2D iChannel0;
		uniform sampler2D iChannel1;
		uniform sampler2D iChannel2;

		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;
		vec4 fragColor;
		
		/*
		void main()
		{
			vec2 uv = gl_FragCoord.xy / iResolution.xy;
			vec4 tex = texture2D(iChannel0, uv);
			gl_FragColor = tex;
			if (uv.x < 0.2) {gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);}
			//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
		*/

		//Fluid Algorithm  https://www.shadertoy.com/view/MtdBDB
		vec2 R;
		float N;
		vec4 Q;
		vec2 U;

		vec4 T ( vec2 U ) {
			return texture2D(iChannel0,U/R);
		}

		float X (vec2 U0, vec2 U, vec2 U1, inout vec4 Q, in vec2 r) {
			vec2 V = U + r, u = T(V).xy,
				V0 = V - u,
				V1 = V + u;
			float P = T (V0).z, rr = length(r);
			Q.xy -= r*(P-Q.z)/rr/N;
			return (0.5*(length(V0-U0)-length(V1-U1))+P)/N;
		}

		float ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input
			return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));
		}

		void main()
		{   
			U = gl_FragCoord.xy;
			R = iResolution.xy;
			vec2 U0 = U - T(U).xy;
			vec2 U1 = U + T(U).xy;
			float P = 0.;
			Q = T(U0);
			N = 4.;
			P += X (U0,U,U1,Q, vec2( 1., 0.) );
			P += X (U0,U,U1,Q, vec2( 0.,-1.) );
			P += X (U0,U,U1,Q, vec2(-1., 0.) );
			P += X (U0,U,U1,Q, vec2( 0., 1.) );
			Q.z = P;
			if (iFrame < 1) Q = vec4(0.); // start transparent
			if (U.x < 1.||U.y < 1.||R.x-U.x < 1.||R.y-U.y < 1.) Q.xy *= 0.;
			
			if (length(U-vec2(0.1,0.5)*R) < .03*R.y) 
				Q.xy= Q.xy*.9+.1*vec2(.5,-.3);
			if (length(U-vec2(0.7,0.3)*R) < .03*R.y) 
				Q.xy= Q.xy*.9+.1*vec2(-.6,.3);
			if (length(U-vec2(0.2,0.2)*R) < .03*R.y) 
				Q.xy= Q.xy*.9+.1*vec2(.4,.6);
			if (length(U-vec2(0.7,0.5)*R) < .03*R.y) 
				Q.xy= Q.xy*.9+.1*vec2(-.1,-.3);
			if (length(U-vec2(0.5,0.6)*R) < .03*R.y) 
				Q.xy= Q.xy*.9+.1*vec2(0,-.7);
			
			vec4 mo = texture2D(iChannel2,vec2(0));
			//vec4 mo = vec4(0.);
			float l = ln(U,mo.xy,mo.zw);
			if (mo.z > 0. && l < 10.) {
				Q.xyz += vec3((10.-l)*(mo.xy-mo.zw)/R.y,(10.-l)*(length(mo.xy-mo.zw)/R.y)*0.02);
			}
			gl_FragColor = Q;
		}
		
	  </script>


    <script id="fragmentShader_buffer_B" type="x-shader/x-fragment">
        //#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;

		vec4 fragColor;
		uniform sampler2D iChannel0; // takes buffer of self
		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;

		/*
		 void main()
		{
			gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
		}
        */

		
		//Based on https://www.shadertoy.com/view/4sK3WK by stb - thank you for your help!
        //Simplified drawing only, no deleting cells, no moving cells. See original for that

        //const float Key_R = 82.5 / 256.;

        #define t2D(o) texture2D(iChannel0, uv-(o/res))               // in 0-1 range
        //#define isKeyHeld(key) texture2D(iChannel3, vec2(key, .2)).r > 0.
        #define dataAt(x) texture2D(iChannel0, vec2(x+.5, .5)/res)

        //#define dataAt(x) texture2D(iChannel0, vec2(x, 0.)/res)     // check if halfpoint is necessary


        // hash without sine
        // https://www.shadertoy.com/view/4djSRW
        #define MOD3 vec3(443.8975,397.2973, 491.1871)
        float hash12(vec2 p) {
            vec3 p3  = fract(vec3(p.xyx) * MOD3);
            p3 += dot(p3, p3.yzx + 19.19);
            return fract((p3.x + p3.y) * p3.z);
        }

        //void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
        void main() {
            vec2 res = iResolution.xy;
            vec2 fc = gl_FragCoord.xy;
            vec2 uv = fc / res;
            vec3 o = vec3(1., -1., 0.);
            
            // set up neighborhood filter size 3
            vec2 dirs[8];
            dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;
            dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;
            
            // get current pixel position from last frame - (uv-(0.,0)/res)
            vec2 pos = t2D(o.zz).rg;  // current position, processed from last frame, stored in RG
            
            // get data about mouse from previous frame - savedPosition
            //vec2 sPos = dataAt(2.).ba;  // moving frame - if mouse hold BA - at (2.5, .5)/res;
            
            
            vec2 mOld = dataAt(0.).ba;  // mouseOld BA - at (0., 0.5)/res
            
            // is the mouse being held? - if so there would be data in z/b channel of previous frame
            float isMHeld; // = dataAt(1.).b;  
            
            // NEIGHBORHOOD PROCESSING
            for(int i=0; i<8; i++) {
                // neighbor's stored position
                vec2 iPos = t2D(dirs[i]).rg;
                
                // if circle produced by neighbor is less than the current one, take its position
                if(length(fc-iPos) < length(fc-pos))
                    pos = iPos;
            }
            
            // If mouse is held
            bool mouseHeld = true;
            mouseHeld = iMouse.z>0.;
            
            if(mouseHeld) {
                // cell position under mouse
                // uses t-input as a way to map coordinate - not necessary!
                vec2 posUnderMouse = iMouse.xy/res;  //texture(iChannel0, iMouse.xy/res).rg; 
                
                
                // Do checks for all of the buttons
                // remove cell
            /*
                if (isKeyHeld(Key_X)) {       // ---------------- REPLACE WITH EXTERNAL UNIFORM
                    if(pos==posUnderMouse) {
                        pos = vec2(-10000.); // make black
                    }
                }
            */

                // add cell
                if(length(fc.xy-iMouse.xy) < length(fc.xy-pos.xy) ){
                    pos = iMouse.xy;
                }        
                isMHeld = 1.; // mouse was held this frame - will get stored and passed to next frame        
            }
            
            else {
            isMHeld = 0.; // mouse was not held this frame 
            }
            

            mOld = iMouse.xy;  // mouse on screen - not normalized
            
        
        
                
            // initialize values first frame
            // this is where it makes a sphere at first 
            float sphereShape = 64.;
            if(iFrame == 0) {
                if(pow(length(fc/res.y-vec2(.5*res.x/res.y, 0.)), sphereShape) > hash12(uv)) {
                    //pos = fc;  // multiplying a scalar here is dope
                }
                else {
                    //pos = vec2(-10000.); 
                }
                isMHeld = 0.;
            }
            
            // ------- CLEAR FRAMEBUFFER --------
            // clear stored positions when R is pressed    // ---------------- REPLACE WITH EXTERNAL UNIFORM
            //if(isKeyHeld(Key_R))
            //  pos = vec2(-10000.);
            // or could also be done on frame
            //if(iFrame == 100)
            //    pos = vec2(-10000.);
            
            
            
            
            // ------- STORE OUTPUTS --------
            
            // save cell position(s) - RG
            fragColor.rg = floor(pos);                  // IS CORRECT
            
            
            // STORE MOUSE POS
            // save old mouse position - if current pixel (o.zz) is this fragcoord - put in BA
            if(floor(fc)==o.zz) {      // floor(fc) gives only integer coords, not #.5 coords
                //fragColor.ba = mOld;   // store straight mouse.xy in BA
            }

            
           

            // STORE BUTTON STATES - NOT IN USE    
            /*
            else
                // save button held state in this coordinate, right of current - B
                if(floor(fc)==o.xz)
                    fragColor.b = isMHeld; // float, if mouse was held in this frame, in B
            */        
            


            // SANITY CHECKS

            // Sanity check -  remember straight reading of texture in image
            //fragColor = vec4(1.,0.,0.,1); 
            
            // DEBUG CHECKS
            //fragColor = vec4(vec3(isMHeld),1); // float check
            //fragColor = vec4(mOld,0.,1);  // yellow - straight mouse.xy
            //fragColor = vec4(sPos,0.,1);  // green
            //fragColor = vec4(floor(fc), 0., 1.); // yellow with green and red line at left and bottom

            //fragColor = vec4(texture2D(imgTexture, vUv));
            //fragColor = vec4(texture2D(bufferTexture, vUv));

            // check that my storing works
            if(floor(fc) == vec2(10.,10.)) {  // make a red pixel at this coordinate
                fragColor = vec4(1.,0.,0.,1);
            }
            // Does mouse get read?
            //fragColor.rg = mOld/res; 

            gl_FragColor = fragColor;
        }
         
	  </script>

    <script id="fragmentShader_buffer_C" type="x-shader/x-fragment">
		//#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;
		uniform sampler2D iChannel0;
		uniform sampler2D iChannel1;
		uniform sampler2D iChannel2;

		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;
		vec4 fragColor;

		// keep track of mouse
		//void mainImage( out vec4 fragColor, in vec2 fragCoord )
		void main()
		{
			//vec4 p = texture2D(iChannel0, gl_FragCoord.xy/iResolution.xy);
			vec4 p = texture2D(iChannel0, vUv); // is same

			// if mouse is clicked and
			// if current mousePos x is not 0 - mousePos is actually full pixel range w h
			if (iMouse.z>0.) {
				// check if blue channel was not 0
				if (p.z>0.)
					fragColor =  vec4(iMouse.xy,p.xy);			// be yellow from (w,h,0->1,0->1)
				// if mousepos in previous frame was not clicked - is black
				else
					fragColor =  vec4(iMouse.xy,iMouse.xy);		// be white
			}
			else fragColor = vec4(-iResolution.xy,-iResolution.xy);		// be black
			gl_FragColor = fragColor;

			/*
			// CHECKS
			//gl_FragColor = vec4(iMouse.z/iResolution.x, 0.,0.,1.);
			vec2 uv = gl_FragCoord.xy/iResolution.xy;
			if (uv.x > 0.5)
				gl_FragColor = p;
			
			// mouse pos if mouse was mapped 0-1
			vec2 uv = (gl_FragCoord.xy/iResolution.xy);
			//gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.);
			//gl_FragColor = vec4(uv.x, uv.y, 0., 1.);

			float x = iMouse.x/iResolution.x;           // from external
			float y = ((iMouse.y/iResolution.y) -1. ) * -1.;
			float space = 0.01;
			
			if (uv.x > x-space-0.005 && uv.x < x+space+0.005 && (uv.y > y-space-0.005 && uv.y < y+space+0.005 ))
				gl_FragColor = vec4(0.,0.,0.,1.);
			if (uv.x > x-space && uv.x < x+space && (uv.y > y-space && uv.y < y+space ))
				gl_FragColor = vec4(1.);
			*/
		}

		/*
		 void main()
		{
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		}
		*/
	  </script>


    <script id="fragmentShader_image" type="x-shader/x-fragment">
		//#extension GL_OES_standard_derivatives : enable
		uniform vec2 iResolution;	//The width and height of our screen
		uniform sampler2D bufferTexture;	//Our input texture
		uniform sampler2D imgTexture;
		varying vec2 vUv;
		uniform sampler2D iChannel0;
		uniform sampler2D iChannel1;
		uniform sampler2D iChannel2;

		uniform float iTime;
		uniform int iFrame;
		uniform vec4 iMouse;
		vec4 fragColor;

		/*
		 // straight sampling from img or buffer
		 void main()
		{
			//vec4 tex = texture2D(bufferTexture, gl_FragCoord.xy / iResolution.xy);
			vec4 tex = texture2D(iChannel0, vUv);
            //vec4 tex = texture2D(iChannel1, vUv);
			gl_FragColor = tex;

			//vec4 img = texture2D(imgTexture, gl_FragCoord.xy / iResolution.xy);
			//gl_FragColor = mix(tex.rgb, img.rgb, 0.5);
			//vec2 uv = gl_FragCoord.xy / iResolution.xy;
			//if(uv.x<0.25) gl_FragColor = vec4(1,1,1,1);
			
			//gl_FragColor = vec4(0.,0.,1.,1.);
		}
        */
		
		
		
		//Based on https://www.shadertoy.com/view/4sK3WK by stb - thank you for your help!
        // hit R to remove clear buffer and remove all voronoi, then resample by drawing with mouse.

        #define t2D(o) texture2D(iChannel0, uv-(o/res))
        #define plane(p, n) 1. - abs(dot(p, n))*res.y
        #define dataAt(x,y) texture2D(iChannel0, vec2(x+.5, y+.5)/res)
        //#define dataAt(x,y) texture2D(iChannel0, vec2(x, y)/res)

        //void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
        void main() {
            vec2 res = iResolution.xy;
            vec2 uv = gl_FragCoord.xy / res;
            vec2 p = gl_FragCoord.xy / res.y;
            vec3 o = vec3(1., -1., 0.);
            
            // cross neighborhood processing
            vec2 dirs[4];
            dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;
            
            // current position from the buffer iChannel0
            vec2 pos = t2D(o.zz).rg;
            
            // cell and wall
            float c, w = 0.; 
            
            // distance from center of cell to walls
            float dist = length(p-pos/res.y);
            
            
            // COLOR SETTINGS
            
            // overall cell gradients - these will have different effects
            // depending on the color effects used below
            c = pos.y*0.003;  // overall gradient
            c = pos.y*0.0023;  // overall gradient
            c = pos.y*0.003;  // overall gradient
            
            // helpfull other cell based gradients
             c = 10. * dist; // gradient from center
             c += 1.-step(0.005, dist); // draw cell centers
            
            
            
            // Get texture color
            vec4 tc = texture2D(iChannel1, pos/res.xy); // sample from under mouse
            //vec4 tc = texture2D(iChannel1, uv); // for debugging


            
            // Make cell walls
            for(int i=0; i<6; i++) {
                vec2 iPos = t2D(dirs[i]).rg; // sampling from iChannel0 - RG 
                if(pos!=iPos)
                    w = max(w, plane(p-mix(pos, iPos, .5)/res.y, normalize(pos-iPos)));
                    //w = 1.-w;
            }
            
            // SOME OTHER FUN EFFECTS TO TRY OUT WHEN BLENDING
            // original color with white walls and + colored base (r,g,b)
            // vec4 col = vec4(vec3(c) * vec3(.7, .6, .5) + w , 1.);
            
            // grayscale and white walls
            // vec4 col = vec4(vec3(c) + w , 1.);
            
            // grayscale
            //vec4 col = vec4(vec3(c), 1.);
            
            // gradient on individual tiles (bump mappy look) + texture sampling (uncomment both)
            // c = (p-pos/res.y).r; // gradient from left side, or try .g from below, or res.x
            // vec4 col = vec4(vec3(c) + w , 1.) + tc;
            
            // gradient + texture sampling
            //vec4 col = vec4(vec3(c)*tc.rgb + w, 1.);
            
            // gradient + texture sampling + colored base (r,g,b)
            vec4 col = vec4(vec3(c)*tc.rgb * vec3(.7, .6, .5) + w, 1.);
            
            
            /*
            // turn to alpha in case of layering
            float threshold = 0.99;
            if (col.r > threshold && col.g > threshold && col.b > threshold) {
                //col.rgb= vec3(0.);
                col.a = 0.; 
            }    
            */
            
        
            fragColor = col;
            //fragColor = tc; // show texture sampler
            //fragColor = vec4(texture2D(iChannel0, pos/res.xy).ba, 0, 1); // show texture sampler
            //fragColor = vec4(pos.rg, 0, 1); // show texture sampler

            
            // SANITY CHECK - Show whats in the buffer
            //fragColor = texture(iChannel0, uv);
            //fragColor = texture(iChannel0, vUv);

            // IF THESE CHECKS DON'T WORK, DATA PASSING DOESN'T WORK
            // get that red pixel at coordinate vec2(10.,10.))
            // - color half the image
            if (uv.x > 0.5) {
                fragColor = texture2D(iChannel0, vec2(10,10.)/res);    // get red pixel 1,0,0,1 at coordinate.
                //fragColor = vec4( texture2D(iChannel0, vec2(10,10.)/res).ba,  0., 1.); // get the ba component - draws green
                fragColor = vec4(dataAt(10.,10.));
            }
            // test position data storing
            if (uv.x > 0.5) {
                // fragColor = vec4( texture2D(iChannel0, uv/res).rgb, 1.); // base color
                //fragColor = texture2D(iChannel0, pos.xy);        // get color in position
            }
            // test mouse data storing 
            if (uv.x > 0.5) {
                //fragColor = vec4( texture2D(iChannel0, iMouse.xy).rg,  0., 1.); // 0->res Yellow
                //fragColor = vec4( texture2D(iChannel0, iMouse.xy/res)); // 0->1 sample mouse straight from texture
            }

            gl_FragColor = fragColor;
        }
	  </script>


    <script>
        // THREE JS PROGRAM
        var scene;
        var camera;
        var buffercamera;

        var renderer;
        var bufferScene;
        var bufferScene_A;
        var bufferScene_B;
        var bufferScene_C;
        var bufferScene_D;

        var textureA;
        var textureB;
        var textureC;
        var textureD;
        var textureCC;
        var textureBB;
        var textureImage;

        var bufferMaterial;
        var bufferMaterial_A;
        var bufferMaterial_B;
        var bufferMaterial_C;
        var bufferMaterial_D;

        var bufferObject_A;
        var bufferObject_B;
        var bufferObject_C;
        var bufferObject_D;

        var plane;
        var plane_A;
        var plane_B;
        var plane_c;
        var plane_D;

        var finalMaterial;
        var quad;


        var texTest = new THREE.TextureLoader().load('textures/butterfly.png');

        const width = window.innerWidth;
        const height = window.innerHeight;
        const rtWidth = window.innerWidth;
        const rtHeight = window.innerHeight;

        var iTime;
        var iFrame;
        const iMouse = new THREE.Vector4();
        var iMousePressed = false;
        var startTime = Date.now();
        var timeScalar = 1.;




        const PARAMS = {
            wrapS: THREE.RepeatWrapping,
            wrapT: THREE.RepeatWrapping,
            minFilter: THREE.LinearFilter,
            magFilter: THREE.NearestFilter, //THREE.LinearFilter,//
            format: THREE.RGBAFormat,
            type: THREE.FloatType
            //stencilBuffer: true
        };

        function onMouseMove(event) {
            // calculate mouse position in normalized device coordinates
            // (-0.5 to +0.5) for both components
            //iMouse.x = ( event.clientX / window.innerWidth ) - 0.5;
            //iMouse.y = (( event.clientY / window.innerHeight ) - 0.5) * -1.;

            // calculate mouse position in normalized device coordinates
            // 0 - 1
            //iMouse.x = ( event.clientX / window.innerWidth );
            //iMouse.y = (( event.clientY / window.innerHeight ) - 1) * -1.;

            // no mapping - pixel coordinates width and height, but height is flipped
            iMouse.x = event.clientX;
            iMouse.y = height - (event.clientY); //1.0 - uv.y;
            //console.log(iMouse.x);
            //console.log(iMouse.y);
            //console.log(event.buttons);
            if (event.buttons > 0) {	// button is pressed
                //console.log("pressed");
                if (!iMousePressed) { 	// if it wasn't pressed last frame
                    iMouse.z = iMouse.x;
                    iMouse.w = iMouse.y;
                    iMousePressed = true;
                    console.log('iMouse.z');
                    console.log(iMouse.z);
                    console.log(iMouse.w);
                }
            }
            if (event.buttons == 0) {
                iMousePressed = false;
                //iMouse.z = 0.;
                //iMouse.w = 0.;
                //console.log("not pressed");
            }
        }

        function init() {
            window.addEventListener('mousemove', onMouseMove, false);
            var elapsedMilliseconds = Date.now() - startTime;
            //var elapsedSeconds = elapsedMilliseconds / 1000.;
            iTime = elapsedMilliseconds * timeScalar;
            iFrame = 0;

            textureA = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            textureB = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            textureC = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            textureD = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            textureCC = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            textureBB = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
        }

        function sceneSetup() {
            console.log("Scene loaded -----------");
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
            camera.position.z = 2;

            // create final texture
            textureImage = new THREE.WebGLRenderTarget(rtWidth, rtHeight, PARAMS);
            //finalMaterial =  new THREE.MeshBasicMaterial({map: textureImage.texture});
            finalMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    bufferTexture: { type: "t", value: textureA.texture },
                    iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
                    imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/butterfly.png') },
                    iChannel0: { type: "t", value: textureB.texture },
                    iChannel1: { type: "t", value: new THREE.TextureLoader().load('textures/color.png') },
                    //iChannel2: { type: "t", value: textureCC.texture },
                    iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
                    iFrame: { type: "i", value: 0 },
                    iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader_image').textContent,
                extensions: {
                    derivatives: true, // set to use derivatives
                    fragDepth: true, // set to use fragment depth values
                    drawBuffers: true, // set to use draw buffers
                    shaderTextureLOD: true // set to use shader texture LOD
                }
            });

            plane = new THREE.PlaneBufferGeometry(rtWidth, rtHeight);
            quad = new THREE.Mesh(plane, finalMaterial);
            scene.add(quad);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(rtWidth, rtHeight);
            document.body.appendChild(renderer.domElement);

            var gl = this.renderer.getContext();
            if (!gl.getExtension("OES_texture_float")) {
                console.error("No OES_texture_float support for float textures!");
            }
        }


        function bufferTextureSetup() {
            buffercamera = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, 1, 1000);
            buffercamera.position.z = 2;
            //Create buffer scene
            bufferSceneA = new THREE.Scene();
            bufferSceneB = new THREE.Scene();
            bufferSceneC = new THREE.Scene();
            bufferSceneD = new THREE.Scene();

            //Pass texture to shader
            bufferMaterial_A = new THREE.ShaderMaterial({
                uniforms: {
                    //bufferTexture: { type: "t", value: textureA.texture },
                    iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
                    imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
                    //iChannel0: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
                    iChannel0: { type: "t", value: textureD.texture },
                    //iChannel1: { type: "t", value: textureB.texture },
                    iChannel2: { type: "t", value: textureC.texture },
                    iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
                    iFrame: { type: "i", value: 0 },
                    iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader_buffer_A').innerHTML
            });

            //Pass texture to shader
            bufferMaterial_B = new THREE.ShaderMaterial({
                uniforms: {
                    bufferTexture: { type: "t", value: new THREE.TextureLoader().load('textures/color.png') },
                    iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
                    imgTexture: { type: "t", value: texTest },
                    iChannel0: { type: "t", value: textureBB.texture },
                    //iChannel1: { type: "t", value:  textureBB.texture },
                    //iChannel2: { type: "t", value: textureC.texture },
                    iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
                    iFrame: { type: "i", value: 0 },
                    iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader_buffer_B').innerHTML,
                extensions: {
                    derivatives: true, // set to use derivatives
                    fragDepth: true, // set to use fragment depth values
                    drawBuffers: true, // set to use draw buffers
                    shaderTextureLOD: true // set to use shader texture LOD
                }
            });

            //Pass texture to shader
            bufferMaterial_C = new THREE.ShaderMaterial({
                uniforms: {
                    bufferTexture: { type: "t", value: textureA.texture },
                    iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
                    imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
                    iChannel0: { type: "t", value: textureCC.texture },
                    //iChannel1: { type: "t", value: textureB.texture },
                    //iChannel2: { type: "t", value: textureC.texture },
                    iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
                    iFrame: { type: "i", value: 0 },
                    iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader_buffer_C').innerHTML
            });
            bufferMaterial_D = new THREE.ShaderMaterial({
                uniforms: {
                    //bufferTexture: { type: "t", value: textureA.texture },
                    iResolution: { type: 'v2', value: new THREE.Vector2(rtWidth, rtHeight) },
                    imgTexture: { type: "t", value: new THREE.TextureLoader().load('textures/img.png') },
                    iChannel0: { type: "t", value: textureA.texture },
                    //iChannel1: { type: "t", value: textureB.texture },
                    iChannel2: { type: "t", value: textureC.texture },
                    iTime: { type: "f", value: Math.random() * Math.PI * 2 + Math.PI },
                    iFrame: { type: "i", value: 0 },
                    iMouse: { type: "v4", value: new THREE.Vector4(iMouse.x, iMouse.y, iMouse.z, iMouse.w) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader_buffer_A').innerHTML
            });
            /*
            bufferMaterial_A.material.extensions.derivatives = true;
            bufferMaterial_B.material.extensions.derivatives = true;
            bufferMaterial_C.material.extensions.derivatives = true;
            bufferMaterial_D.material.extensions.derivatives = true;
            */
            plane_A = new THREE.PlaneBufferGeometry(rtWidth, rtHeight);
            plane_B = new THREE.PlaneBufferGeometry(rtWidth, rtHeight);
            plane_C = new THREE.PlaneBufferGeometry(rtWidth, rtHeight);
            plane_D = new THREE.PlaneBufferGeometry(rtWidth, rtHeight);
            bufferObject_A = new THREE.Mesh(plane_A, bufferMaterial_A);
            bufferSceneA.add(bufferObject_A);
            bufferObject_B = new THREE.Mesh(plane_B, bufferMaterial_B);
            bufferSceneB.add(bufferObject_B);
            bufferObject_C = new THREE.Mesh(plane_C, bufferMaterial_C);
            bufferSceneC.add(bufferObject_C);
            bufferObject_D = new THREE.Mesh(plane_D, bufferMaterial_D);
            bufferSceneD.add(bufferObject_D);

            console.log(textureB);
        }


        //Initialize the Threejs scene that will render to the screen
        init();
        sceneSetup();
        bufferTextureSetup(); //Setup the frame buffer scenes we're going to be rendering to instead of the screen


        function render() {
            requestAnimationFrame(render);

            // RENDER BUFFERS
            /*
            // Make shader on quad BufferA - change input buffers - Draw bufferScene to textureA
            renderer.setRenderTarget(textureA);
            //renderer.render(bufferSceneA,buffercamera,textureA,true);
            renderer.render(bufferSceneA, buffercamera);
            //finalMaterial.uniforms.bufferTexture.value = textureA.texture;	// test that it gets passed into image
            renderer.setRenderTarget(null);
            */


            // Make shader on quad BufferB - change input buffers - Draw bufferScene to textureB
            renderer.setRenderTarget(textureB);
            //renderer.render(bufferSceneB,buffercamera,textureB,true);
            renderer.render(bufferSceneB, buffercamera);
            renderer.setRenderTarget(null);
            textureBB = textureB;

            /*
            // Make shader on quad BufferC - change input buffers - Draw bufferScene to textureC
            renderer.setRenderTarget(textureC);
            //renderer.render(bufferSceneC,buffercamera,textureC,true);
            renderer.render(bufferSceneC, buffercamera);
            //finalMaterial.uniforms.bufferTexture.value = textureC.texture;	// test that it gets passed into image
            renderer.setRenderTarget(null);
            textureCC = textureC;

            // Make shader on quad BufferC - change input buffers - Draw bufferScene to textureC
            renderer.setRenderTarget(textureD);
            //renderer.render(bufferSceneD,buffercamera,textureD,true);
            renderer.render(bufferSceneD, buffercamera);
            //finalMaterial.uniforms.bufferTexture.value = textureD.texture;	// test that it gets passed into image
            renderer.setRenderTarget(null);
            */

            /*
            bufferMaterial_A.uniforms.iChannel0.value = textureD.texture;
            bufferMaterial_B.uniforms.iChannel0.value = textureA.texture;
            bufferMaterial_B.uniforms.iChannel1.value = textureBB.texture;
            finalMaterial.uniforms.iChannel0.value = textureA.texture;
            finalMaterial.uniforms.iChannel1.value = textureBB.texture;
            */

            bufferMaterial_A.uniforms.iMouse.value = iMouse;
            bufferMaterial_B.uniforms.iMouse.value = iMouse;
            bufferMaterial_C.uniforms.iMouse.value = iMouse;
            bufferMaterial_D.uniforms.iMouse.value = iMouse;


            bufferMaterial_A.uniforms.iTime.value = iTime;
            bufferMaterial_A.uniforms.iFrame.value = iFrame;
            bufferMaterial_B.uniforms.iTime.value = iTime;
            bufferMaterial_B.uniforms.iFrame.value = iFrame;
            /*
            bufferMaterial_C.uniforms.iTime.value = iTime;
            bufferMaterial_C.uniforms.iFrame.value = iFrame;
            bufferMaterial_D.uniforms.iTime.value = iTime;
            bufferMaterial_D.uniforms.iFrame.value = iFrame;
            */

            finalMaterial.uniforms.iTime.value = iTime;
            finalMaterial.uniforms.iFrame.value = iFrame;
            finalMaterial.uniforms.iMouse.value = iMouse;

            //finalMaterial.uniforms.bufferTexture.value = textureA.texture;	// test that it gets passed into image

            /*
            textureA.needsUpdate = true;
            textureB.needsUpdate = true;
            textureC.needsUpdate = true;
            textureD.needsUpdate = true;
            textureCC.needsUpdate = true;
        	
            */



            finalMaterial.uniforms.iChannel0.value = textureB.texture;


            //Update uniforms
            var elapsedMilliseconds = Date.now() - startTime;
            var elapsedSeconds = elapsedMilliseconds / 1000.;
            iTime = elapsedMilliseconds * timeScalar; 			//60. * elapsedSeconds;
            //iTime += 1.;
            iFrame += 1;

            //bufferMaterial_B.uniforms.iChannel0.value = texTest;
            //bufferMaterial_B.uniforms.iChannel0.value = textureBB.texture;

            //Finally, draw to the screen
            //quad.material.map = textureA.texture;
            //quad.material.map = textureImage.texture;

            // RENDER WHAT WE SEE
            renderer.render(scene, camera);

            // Swap the render targets
            var tmp = textureBB;
            textureBB = textureB;
            textureBB.needsUpdate = true;

            //textureB = tmp;
        }
        render();
    </script>
</body>

</html>